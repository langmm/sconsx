

import os
import re

from openalea.sconsx.util.hexversion import *


def get_var_from_py_config(fname):
    result = {}
    mglobals = {}
    if os.path.exists(fname):
        exec(compile(open(fname, "rb").read(), fname, 'exec'), mglobals, result)
    return result

def generate_py_config(variables, fname, project):
    print('Generate py config in',repr(fname))
    stream = open(fname,'w')
    stream.write('################################################################\n')
    stream.write('# User configuration of the '+project+' project.\n')
    stream.write('################################################################\n')
    stream.write('# This file is automatically generated. Do not edit it directly.\n')
    stream.write('################################################################\n\n\n')
    writetype = { }
    for varname, varvalue in list(variables.items()):
        if not varvalue is None or type(varvalue) == instance:
            stream.write(varname+' = '+writetype.get(type(varvalue), repr)(varvalue)+'\n\n')


def get_var_from_cpp_config(fname = os.path.join('src', 'cpp', 'plantgl', 'userconfig.h')):
    result = {}
    pattern = '#define'
    if os.path.exists(fname):
        stream = file(fname,'r')
        for line in stream.readlines():
            if line.startswith(pattern):
                var,value = list(map(str.strip,line[len(pattern)+1:].split(' ',1)))
                result[var] = eval(value)
    return result

def generate_cpp_config(variables, fname, project):
    print('Generate cpp config in',repr(fname))
    stream = open(fname,'w')
    stream.write('/***************************************************************\n')
    stream.write(' * User configuration of the '+project+' project.\n')
    stream.write(' ***************************************************************\n')
    stream.write(' * This file is automatically generated. Do not edit it directly.\n')
    stream.write(' ***************************************************************/\n\n\n')
    writetype = { bool : lambda v : '1' if v else '0', str : lambda v : '"'+repr(v)[1:-1]+'"'}
    for varname, varvalue in list(variables.items()):
        if not varvalue is None:
            stream.write('#define '+varname+' '+writetype.get(type(varvalue), repr)(varvalue)+'\n\n')

def is_similar(vars1, vars2, debug = False):
    if len(set(vars1.keys()).symmetric_difference(vars2)) > 0 : 
        if debug : print (set(vars1.keys()).symmetric_difference(vars2))
        return False
    for var, value in list(vars1.items()):
        symvalue = vars2[var]
        if type(value) == bool or type(symvalue) == bool :
            if int(value) != int(symvalue):
                if debug : rint (var, value, symvalue)
                return False
        elif value != symvalue : 
            if debug : print (var, value, symvalue,type(value),type(symvalue))
            return False
    return True

condapattern = '{{% set version = "{}" %}}'
condaregpattern = condapattern.format("(?P<version>[0-9]+.[0-9]+.[0-9]+)").replace(' ','[ \t]+')

def get_version_from_conda(fname):
    result = re.search(condaregpattern, file(fname,'r').read())
    if not result is None:
        version_str = result.group("version")
        return HexVersion.from_string(version_str)


def generate_conda_version(version, fname):
    print('Update conda config in',repr(fname))
    result = re.sub(condaregpattern, condapattern.format(version.to_string()),file(fname,'r').read(),1)
    file(fname,'w').write(result)

def generate_config(project,
                    config, 
                    pyconfigfname,
                    cppconfigfname,
                    debug = False):

    if not pyconfigfname is None:
        pyconfig = get_var_from_py_config(pyconfigfname)
        if not is_similar(config,pyconfig,debug):
            generate_py_config(config, pyconfigfname, project)

    if not cppconfigfname is None:
        cppconfig = get_var_from_cpp_config(cppconfigfname)
        if not is_similar(config,cppconfig,debug):
            generate_cpp_config(config, cppconfigfname, project)


def generate_conda_config(version,
                          condaconfigfname = os.path.join('conda','meta.yaml'),
                          debug = False):
    if not condaconfigfname is None:
        condaversion = get_version_from_conda(condaconfigfname)
        if version != condaversion:
            if debug : print ('Detect difference of version in code and conda meta.yaml :', version, condaversion)
            generate_conda_version(version, condaconfigfname)

def get_config_from_env(env, config, prefix = None):
    if prefix:
        var = lambda x : prefix + '_' + x
    else:
        var = lambda x : x

    if 'WITH_FLEX' in env or 'WITH_BISON' in env:
        config[var('WITH_BISONFLEX')] = (env['WITH_FLEX'] and env['WITH_BISON'])

    if 'WITH_CGAL' in env:
        config[var('WITH_CGAL')]  = env['WITH_CGAL']

    if 'WITH_QHULL' in env:
        config[var('WITH_QHULL')] = env['WITH_QHULL']

    if 'WITH_ANN' in env:
        config[var('WITH_ANN')]   = env['WITH_ANN']

    if 'WITH_BOOST' in env:
        config[var('WITH_BOOST')] = env.get('WITH_BOOST')

    return config